using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Lumina;
using Lumina.Data;
using Lumina.Text;
using ActionRow = Lumina.Excel.Sheets.Action;
using ClassJobCategoryRow = Lumina.Excel.Sheets.ClassJobCategory;
using StatusRow = Lumina.Excel.Sheets.Status;

internal static class Program
{
    private const string ApiBase = "https://beta.xivapi.com/api/1/";
    private const string SkillPotStart = "// <auto-generated: SkillPot>";
    private const string SkillPotEnd = "// </auto-generated: SkillPot>";
    private const string DotPotStart = "// <auto-generated: DotPot>";
    private const string DotPotEnd = "// </auto-generated: DotPot>";
    private static readonly Regex NumberRegex = new(@"\b(\d+)\b", RegexOptions.Compiled);

    private static readonly string[] CombatJobProps =
    [
        "GLA", "PGL", "MRD", "LNC", "ARC", "CNJ", "THM",
        "PLD", "MNK", "WAR", "DRG", "BRD", "WHM", "BLM",
        "ACN", "SMN", "SCH", "ROG", "NIN", "MCH", "DRK",
        "AST", "SAM", "RDM", "BLU", "GNB", "DNC", "RPR",
        "SGE", "VPR", "PCT"
    ];

    private static readonly PropertyInfo[] CombatJobFlags = typeof(ClassJobCategoryRow)
        .GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.PropertyType == typeof(bool) && CombatJobProps.Contains(p.Name, StringComparer.Ordinal))
        .ToArray();

    private static readonly Dictionary<uint, uint> ActionDotStatusOverrides = new()
    {
        { 11386, 273 }, // Song of Torment -> Bleeding
        { 11390, 272 }, // Aqua Breath -> Dropsy
        { 11426, 269 }, // Feather Rain -> Windburn
        { 23281, 273 }, // Aetherial Spark -> Bleeding
        { 23290, 1228 }, // Nightbloom -> Higanbana
        { 34569, 3636 }, // Peat Pelt -> Begrimed
    };

    public static async Task<int> Main(string[] args)
    {
        var options = Options.Parse(args);
        if (options == null)
        {
            PrintUsage();
            return 1;
        }

        if (!string.IsNullOrWhiteSpace(options.Ff14McpDotsPath))
        {
            var targetPotencyPath = ResolvePotencyPath(options.PotencyPath);
            var ff14McpPath = ResolveFf14McpDotsPath(options.Ff14McpDotsPath);
            UpdateDotPotFromFf14Mcp(ff14McpPath, targetPotencyPath);
            Console.WriteLine($"Updated {targetPotencyPath}");
            return 0;
        }

        var sqpackPath = ResolveGamePath(options.GamePath);
        if (sqpackPath == null)
        {
            Console.Error.WriteLine("Could not locate the FFXIV sqpack folder. Use --game <path>.");
            return 1;
        }

        Console.WriteLine($"Using sqpack: {sqpackPath}");

        if (options.DumpStatusSchema)
        {
            DumpStatusSchema();
            return 0;
        }

        if (options.DumpActionSchema)
        {
            DumpActionSchema();
            return 0;
        }

        if (options.DumpActionTransientSchema)
        {
            DumpActionTransientSchema();
            return 0;
        }

        if (options.DumpActionProcStatusSchema)
        {
            DumpActionProcStatusSchema();
            return 0;
        }

        if (options.ListSheetsFilter != null)
        {
            DumpSheetTypes(options.ListSheetsFilter);
            return 0;
        }

        if (options.DumpAozActionSchema)
        {
            DumpAozActionSchema();
            return 0;
        }

        if (options.DumpAozActionTransientSchema)
        {
            DumpAozActionTransientSchema();
            return 0;
        }

        if (!string.IsNullOrWhiteSpace(options.SheetSchemaName))
        {
            DumpSheetSchema(options.SheetSchemaName);
            return 0;
        }

        if (options.ActionDumpIds.Count > 0 || options.ActionNameQueries.Count > 0 || options.StatusQueries.Count > 0 || options.StatusDescriptionQueries.Count > 0 || options.StatusActionIds.Count > 0 || options.StatusIconQueries.Count > 0 || options.StatusDumpIds.Count > 0 || !string.IsNullOrWhiteSpace(options.StatusJobFilter))
        {
            if (options.ActionDumpIds.Count > 0)
            {
                DumpActionInfo(sqpackPath, options.ActionDumpIds, options.QueryLanguage);
            }

            if (options.ActionNameQueries.Count > 0)
            {
                DumpActionMatches(sqpackPath, options.ActionNameQueries, options.QueryLanguage);
            }

            if (options.StatusQueries.Count > 0)
            {
                DumpStatusMatches(sqpackPath, options.StatusQueries, options.QueryLanguage);
            }

            if (options.StatusDescriptionQueries.Count > 0)
            {
                DumpStatusDescriptionMatches(sqpackPath, options.StatusDescriptionQueries, options.QueryLanguage);
            }

            if (options.StatusActionIds.Count > 0)
            {
                DumpStatusByAction(sqpackPath, options.StatusActionIds, options.QueryLanguage);
            }

            if (options.StatusIconQueries.Count > 0)
            {
                DumpStatusByIcon(sqpackPath, options.StatusIconQueries, options.QueryLanguage);
            }

            if (options.StatusDumpIds.Count > 0)
            {
                DumpStatusInfo(sqpackPath, options.StatusDumpIds, options.QueryLanguage);
            }

            if (!string.IsNullOrWhiteSpace(options.StatusJobFilter))
            {
                DumpStatusByJob(sqpackPath, options.StatusJobFilter!, options.StatusPotencyFilter, options.QueryLanguage);
            }

            return 0;
        }

        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = Language.ChineseSimplified,
        });

        var (actionIds, actionLocalNames) = GetCombatActionIds(gameData);
        Console.WriteLine($"Combat actions found: {actionIds.Count}");

        using var httpClient = new HttpClient
        {
            BaseAddress = new Uri(ApiBase),
            Timeout = TimeSpan.FromSeconds(20),
        };

        var statusNameToId = GetStatusNameMap(gameData);
        Console.WriteLine($"Statuses loaded: {statusNameToId.Count}");

        var skillPot = new ConcurrentDictionary<uint, float>();
        var dotPot = new ConcurrentDictionary<uint, uint>();
        var actionNames = new ConcurrentDictionary<uint, string>();
        var warnings = new ConcurrentBag<string>();

        await FetchActionPotenciesAsync(
            httpClient,
            actionIds,
            actionLocalNames,
            statusNameToId,
            skillPot,
            dotPot,
            actionNames,
            warnings,
            actionIds.Count,
            options.MaxConcurrency,
            options.CancellationToken);

        var potencyPath = ResolvePotencyPath(options.PotencyPath);
        UpdatePotencyFile(potencyPath, skillPot, dotPot, actionNames);

        Console.WriteLine($"Updated {potencyPath}");
        Console.WriteLine($"SkillPot entries: {skillPot.Count}");
        Console.WriteLine($"DotPot entries: {dotPot.Count}");

        if (!warnings.IsEmpty)
        {
            var warnPath = Path.Combine(Path.GetDirectoryName(potencyPath) ?? ".", "Potency.update.warnings.txt");
            File.WriteAllLines(warnPath, warnings.OrderBy(w => w));
            Console.WriteLine($"Warnings written to {warnPath}");
        }

        return 0;
    }

    private static void PrintUsage()
    {
        Console.WriteLine("Usage:");
        Console.WriteLine("  dotnet run --project tools/PotencyUpdater -- [--game <sqpack|game|exe path>] [--potency <Potency.cs path>] [--max-concurrency <n>] [--find-action <name>] [--find-status <name>] [--find-status-desc <text>] [--find-status-icon <iconId>] [--dump-action <id>] [--dump-status <id>] [--status-action <id>] [--status-job <abbr>] [--status-potency <n>] [--lang <cn|en|ja|de|fr|tw>] [--status-schema] [--action-schema] [--action-transient-schema] [--action-proc-schema] [--list-sheets [filter]] [--aoz-action-schema] [--aoz-action-transient-schema] [--sheet-schema <name>]");
        Console.WriteLine();
        Console.WriteLine("  dotnet run --project tools/PotencyUpdater -- [--potency <Potency.cs path>] --ff14mcp-dots <ff14-mcp root|dots_by_job.json>");
    }

    private static string? ResolveGamePath(string? arg)
    {
        if (!string.IsNullOrWhiteSpace(arg))
        {
            var candidate = NormalizeGamePath(arg);
            if (Directory.Exists(candidate))
            {
                return candidate;
            }
        }

        var fromLog = TryFindSqpackFromLauncherLog();
        if (fromLog != null && Directory.Exists(fromLog))
        {
            return fromLog;
        }

        return null;
    }

    private static string NormalizeGamePath(string input)
    {
        var path = input.Trim().Trim('"');
        if (path.EndsWith("ffxiv_dx11.exe", StringComparison.OrdinalIgnoreCase))
        {
            path = Path.GetDirectoryName(path) ?? path;
        }

        if (path.EndsWith("sqpack", StringComparison.OrdinalIgnoreCase))
        {
            return path;
        }

        return Path.Combine(path, "sqpack");
    }

    private static string? TryFindSqpackFromLauncherLog()
    {
        var logPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "XIVLauncherCN", "argReader.log");
        if (!File.Exists(logPath))
        {
            return null;
        }

        var lines = File.ReadAllLines(logPath);
        for (var i = lines.Length - 1; i >= 0; i--)
        {
            var line = lines[i];
            if (!line.Contains("ffxiv_dx11.exe", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var match = Regex.Match(line, @"[A-Z]:\\[^\s""]+ffxiv_dx11\.exe", RegexOptions.IgnoreCase);
            if (!match.Success)
            {
                continue;
            }

            var exePath = match.Value;
            var gameDir = Path.GetDirectoryName(exePath);
            if (string.IsNullOrWhiteSpace(gameDir))
            {
                continue;
            }

            var sqpack = Path.Combine(gameDir, "sqpack");
            if (Directory.Exists(sqpack))
            {
                return sqpack;
            }
        }

        return null;
    }

    private static (HashSet<uint> Ids, Dictionary<uint, string> LocalNames) GetCombatActionIds(GameData gameData)
    {
        var actionSheet = gameData.GetExcelSheet<ActionRow>();
        if (actionSheet == null)
        {
            throw new InvalidOperationException("Action sheet not found. Check the game data path.");
        }

        var ids = new HashSet<uint>();
        var localNames = new Dictionary<uint, string>();
        foreach (var action in actionSheet)
        {
            if (!action.IsPlayerAction || action.IsPvP)
            {
                continue;
            }

            if (!IsCombatCategory(action.ClassJobCategory.Value))
            {
                continue;
            }

            if (action.RowId == 0)
            {
                continue;
            }

            ids.Add(action.RowId);
            if (!localNames.ContainsKey(action.RowId))
            {
                localNames[action.RowId] = action.Name.ExtractText();
            }
        }

        return (ids, localNames);
    }

    private static bool IsCombatCategory(ClassJobCategoryRow category)
    {
        foreach (var prop in CombatJobFlags)
        {
            if ((bool)prop.GetValue(category)!)
            {
                return true;
            }
        }

        return false;
    }

    private static Dictionary<string, uint> GetStatusNameMap(GameData gameData)
    {
        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            throw new InvalidOperationException("Status sheet not found. Check the game data path.");
        }

        var map = new Dictionary<string, uint>(StringComparer.Ordinal);
        foreach (var status in statusSheet)
        {
            var name = status.Name.ExtractText();
            if (string.IsNullOrWhiteSpace(name))
            {
                continue;
            }

            if (!map.ContainsKey(name))
            {
                map.Add(name, status.RowId);
            }
        }

        return map;
    }

    private static async Task FetchActionPotenciesAsync(
        HttpClient client,
        IEnumerable<uint> actionIds,
        Dictionary<uint, string> actionLocalNames,
        Dictionary<string, uint> statusNameToId,
        ConcurrentDictionary<uint, float> skillPot,
        ConcurrentDictionary<uint, uint> dotPot,
        ConcurrentDictionary<uint, string> actionNames,
        ConcurrentBag<string> warnings,
        int totalActions,
        int maxConcurrency,
        CancellationToken ct)
    {
        using var semaphore = new SemaphoreSlim(maxConcurrency);
        var processed = 0;
        var tasks = actionIds.Select(async id =>
        {
            await semaphore.WaitAsync(ct);
            try
            {
                var action = await FetchActionAsync(client, id, ct);
                if (action == null || string.IsNullOrWhiteSpace(action.Name))
                {
                    return;
                }

                actionNames[id] = action.Name;

                var basePotency = ParseBasePotency(action.Description);
                if (basePotency.HasValue)
                {
                    skillPot[id] = basePotency.Value;
                }

                var dotPotency = ParseDotPotency(action.Description);
                if (dotPotency.HasValue)
                {
                    actionLocalNames.TryGetValue(id, out var localName);
                    var statusId = ResolveDotStatusId(id, localName, statusNameToId);
                    if (!statusId.HasValue)
                    {
                        warnings.Add($"Missing status for DOT action {id} ({action.Name})");
                        return;
                    }

                    if (dotPot.TryGetValue(statusId.Value, out var existing) && existing != dotPotency.Value)
                    {
                        warnings.Add($"DOT potency mismatch for status {statusId.Value}: {existing} vs {dotPotency.Value} (action {id} {action.Name})");
                        return;
                    }

                    dotPot[statusId.Value] = dotPotency.Value;
                }
            }
            catch (Exception ex)
            {
                warnings.Add($"Action {id} failed: {ex.Message}");
            }
            finally
            {
                semaphore.Release();
                var current = Interlocked.Increment(ref processed);
                if (current % 50 == 0 || current == totalActions)
                {
                    Console.WriteLine($"Processed {current}/{totalActions}");
                }
            }
        });

        await Task.WhenAll(tasks);
    }

    private static async Task<ActionApiData?> FetchActionAsync(HttpClient client, uint id, CancellationToken ct)
    {
        using var doc = await GetJsonAsync(client, $"sheet/Action/{id}", ct);
        var root = doc.RootElement;

        if (!root.TryGetProperty("fields", out var fields))
        {
            return null;
        }

        var name = fields.TryGetProperty("Name", out var nameElement) ? nameElement.GetString() ?? string.Empty : string.Empty;
        string? description = null;
        if (root.TryGetProperty("transient", out var transient) && transient.TryGetProperty("Description", out var descElement))
        {
            description = descElement.GetString();
        }

        return new ActionApiData(id, name, description);
    }

    private static int? ParseBasePotency(string? description)
    {
        if (string.IsNullOrWhiteSpace(description))
        {
            return null;
        }

        var lines = SplitLines(description);
        var potencies = new List<int>();
        var inDot = false;

        foreach (var rawLine in lines)
        {
            var line = rawLine.Trim();
            if (line.Length == 0)
            {
                continue;
            }

            var lower = line.ToLowerInvariant();
            if (lower.Contains("damage over time"))
            {
                inDot = true;
                continue;
            }

            if (inDot)
            {
                if (lower.StartsWith("duration"))
                {
                    inDot = false;
                }
                continue;
            }

            if (!lower.Contains("potency"))
            {
                continue;
            }

            if (lower.Contains("cure potency") || lower.Contains("healing") || lower.Contains("restores") || lower.Contains("restores hp") || lower.Contains("barrier strength"))
            {
                continue;
            }

            foreach (var number in ExtractNumbers(line))
            {
                potencies.Add(number);
            }
        }

        if (potencies.Count == 0)
        {
            return null;
        }

        return potencies.Max();
    }

    private static uint? ParseDotPotency(string? description)
    {
        if (string.IsNullOrWhiteSpace(description))
        {
            return null;
        }

        var lines = SplitLines(description);
        var inDot = false;

        foreach (var rawLine in lines)
        {
            var line = rawLine.Trim();
            if (line.Length == 0)
            {
                continue;
            }

            var lower = line.ToLowerInvariant();
            if (lower.Contains("damage over time"))
            {
                var immediate = ExtractFirstNumber(line);
                if (immediate.HasValue)
                {
                    return (uint)immediate.Value;
                }

                inDot = true;
                continue;
            }

            if (!inDot)
            {
                continue;
            }

            if (!lower.Contains("potency"))
            {
                if (lower.StartsWith("duration"))
                {
                    inDot = false;
                }
                continue;
            }

            var potency = ExtractFirstNumber(line);
            if (potency.HasValue)
            {
                return (uint)potency.Value;
            }
        }

        return null;
    }

    private static uint? ResolveDotStatusId(uint actionId, string? actionLocalName, Dictionary<string, uint> statusNameToId)
    {
        if (ActionDotStatusOverrides.TryGetValue(actionId, out var overrideId))
        {
            return overrideId;
        }

        if (!string.IsNullOrWhiteSpace(actionLocalName) && statusNameToId.TryGetValue(actionLocalName, out var id))
        {
            return id;
        }

        return null;
    }

    private static IEnumerable<int> ExtractNumbers(string line)
    {
        foreach (Match match in NumberRegex.Matches(line))
        {
            if (int.TryParse(match.Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
            {
                yield return value;
            }
        }
    }

    private static int? ExtractFirstNumber(string line)
    {
        foreach (var number in ExtractNumbers(line))
        {
            return number;
        }

        return null;
    }

    private static string[] SplitLines(string text)
    {
        return text.Split(new[] { "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries);
    }

    private static async Task<JsonDocument> GetJsonAsync(HttpClient client, string relativeUrl, CancellationToken ct)
    {
        const int maxRetries = 3;
        for (var attempt = 1; attempt <= maxRetries; attempt++)
        {
            using var response = await client.GetAsync(relativeUrl, ct);
            if ((int)response.StatusCode == 429 && attempt < maxRetries)
            {
                await Task.Delay(TimeSpan.FromSeconds(attempt), ct);
                continue;
            }

            response.EnsureSuccessStatusCode();
            var stream = await response.Content.ReadAsStreamAsync(ct);
            return await JsonDocument.ParseAsync(stream, cancellationToken: ct);
        }

        throw new HttpRequestException($"Failed to GET {relativeUrl}");
    }

    private static string ResolvePotencyPath(string? arg)
    {
        if (!string.IsNullOrWhiteSpace(arg))
        {
            return Path.GetFullPath(arg);
        }

        var root = Directory.GetCurrentDirectory();
        var candidate = Path.Combine(root, "DalamudACT", "Potency.cs");
        if (File.Exists(candidate))
        {
            return candidate;
        }

        return Path.GetFullPath(Path.Combine(root, "..", "..", "..", "DalamudACT", "Potency.cs"));
    }

    private static string ResolveFf14McpDotsPath(string arg)
    {
        var path = arg.Trim().Trim('"');
        if (string.IsNullOrWhiteSpace(path))
        {
            throw new ArgumentException("ff14mcp dots path is empty.");
        }

        if (Directory.Exists(path))
        {
            var candidate = Path.Combine(path, "data", "dots_by_job.json");
            if (File.Exists(candidate))
            {
                return candidate;
            }

            candidate = Path.Combine(path, "dots_by_job.json");
            if (File.Exists(candidate))
            {
                return candidate;
            }
        }

        if (File.Exists(path))
        {
            return Path.GetFullPath(path);
        }

        throw new FileNotFoundException($"ff14mcp dots file not found: {path}");
    }

    private static void UpdateDotPotFromFf14Mcp(string ff14McpDotsPath, string potencyPath)
    {
        var entries = ReadFf14McpDotEntries(ff14McpDotsPath);
        if (entries.Count == 0)
        {
            Console.Error.WriteLine("ff14mcp dots file contains no entries.");
            return;
        }

        var warnings = new List<string>();
        var ffDotPot = BuildFf14McpDotPot(entries, warnings);

        var originalBytes = File.ReadAllBytes(potencyPath);
        var content = Encoding.Latin1.GetString(originalBytes);
        var newline = content.Contains("\r\n", StringComparison.Ordinal) ? "\r\n" : "\n";

        var mergedDotPot = ParseExistingDotPot(content);
        foreach (var (statusId, potency) in ffDotPot)
        {
            mergedDotPot[statusId] = potency;
        }

        var dotSection = BuildDotPotSection(mergedDotPot, newline);
        content = ReplaceSection(content, DotPotStart, DotPotEnd, dotSection, newline);

        var updatedBytes = Encoding.Latin1.GetBytes(content);
        File.WriteAllBytes(potencyPath, updatedBytes);

        Console.WriteLine($"ff14mcp dots: {entries.Count} entries, {ffDotPot.Count} unique status ids");
        Console.WriteLine($"DotPot entries: {mergedDotPot.Count}");

        if (warnings.Count > 0)
        {
            var warnPath = Path.Combine(Path.GetDirectoryName(potencyPath) ?? ".", "Potency.update.warnings.txt");
            File.WriteAllLines(warnPath, warnings.OrderBy(w => w));
            Console.WriteLine($"Warnings written to {warnPath}");
        }
    }

    private static Dictionary<uint, uint> ParseExistingDotPot(string potencyContent)
    {
        var startIndex = potencyContent.IndexOf(DotPotStart, StringComparison.Ordinal);
        var endIndex = potencyContent.IndexOf(DotPotEnd, StringComparison.Ordinal);
        if (startIndex < 0 || endIndex < 0 || endIndex < startIndex)
        {
            throw new InvalidOperationException($"Markers not found: {DotPotStart} / {DotPotEnd}");
        }

        var section = potencyContent.Substring(startIndex, endIndex - startIndex);
        var matches = Regex.Matches(section, @"\{\s*(\d+)\s*,\s*(\d+)\s*\}", RegexOptions.CultureInvariant);
        var result = new Dictionary<uint, uint>();
        foreach (Match match in matches)
        {
            if (!uint.TryParse(match.Groups[1].Value, NumberStyles.None, CultureInfo.InvariantCulture, out var statusId))
            {
                continue;
            }

            if (!uint.TryParse(match.Groups[2].Value, NumberStyles.None, CultureInfo.InvariantCulture, out var potency))
            {
                continue;
            }

            result[statusId] = potency;
        }

        return result;
    }

    private static IReadOnlyList<Ff14McpDotEntry> ReadFf14McpDotEntries(string path)
    {
        var json = File.ReadAllText(path, Encoding.UTF8);
        var options = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
        };

        var entries = JsonSerializer.Deserialize<List<Ff14McpDotEntry>>(json, options);
        return entries ?? [];
    }

    private static Dictionary<uint, uint> BuildFf14McpDotPot(IReadOnlyList<Ff14McpDotEntry> entries, List<string> warnings)
    {
        var byStatus = entries
            .Where(e => e.StatusId != 0 && e.DotPotency != 0)
            .GroupBy(e => e.StatusId)
            .ToDictionary(g => g.Key, g => g.ToList());

        var result = new Dictionary<uint, uint>();
        foreach (var (statusId, group) in byStatus)
        {
            var byPotency = group
                .GroupBy(e => e.DotPotency)
                .Select(g => new
                {
                    Potency = g.Key,
                    Count = g.Count(),
                    MaxLevel = g.Max(x => x.Level),
                })
                .OrderByDescending(x => x.Count)
                .ThenByDescending(x => x.MaxLevel)
                .ThenByDescending(x => x.Potency)
                .ToList();

            if (byPotency.Count > 1)
            {
                var detail = string.Join(", ", byPotency.Select(x => $"{x.Potency}x{x.Count}@{x.MaxLevel}"));
                warnings.Add($"ff14mcp dot potency conflict for status {statusId}: {detail} (picked {byPotency[0].Potency})");
            }

            result[statusId] = byPotency[0].Potency;
        }

        return result;
    }

    private static void DumpStatusMatches(string sqpackPath, List<string> queries, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        foreach (var query in queries)
        {
            Console.WriteLine($"Status matches for \"{query}\":");
            var matches = statusSheet
                .Select(status => new { status.RowId, Name = status.Name.ExtractText() })
                .Where(status => status.Name.Contains(query, StringComparison.OrdinalIgnoreCase))
                .OrderBy(status => status.RowId)
                .ToList();

            if (matches.Count == 0)
            {
                Console.WriteLine("  (none)");
                continue;
            }

            foreach (var match in matches)
            {
                Console.WriteLine($"  {match.RowId} - {match.Name}");
            }
        }
    }

    private static void DumpActionMatches(string sqpackPath, List<string> queries, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var actionSheet = gameData.GetExcelSheet<ActionRow>();
        if (actionSheet == null)
        {
            Console.Error.WriteLine("Action sheet not found.");
            return;
        }

        foreach (var query in queries)
        {
            Console.WriteLine($"Action matches for \"{query}\":");
            var matches = actionSheet
                .Where(action => action.IsPlayerAction && !action.IsPvP)
                .Select(action => new { action.RowId, Name = action.Name.ExtractText(), action.Icon })
                .Where(action => action.Name.Contains(query, StringComparison.OrdinalIgnoreCase))
                .OrderBy(action => action.RowId)
                .ToList();

            if (matches.Count == 0)
            {
                Console.WriteLine("  (none)");
                continue;
            }

            foreach (var match in matches)
            {
                Console.WriteLine($"  {match.RowId} - {match.Name} (Icon {match.Icon})");
            }
        }
    }

    private static void DumpStatusDescriptionMatches(string sqpackPath, List<string> queries, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        foreach (var query in queries)
        {
            Console.WriteLine($"Status description matches for \"{query}\":");
            var matches = statusSheet
                .Select(status => new
                {
                    status.RowId,
                    Name = status.Name.ExtractText(),
                    Description = status.Description.ExtractText(),
                    status.ParamModifier,
                })
                .Where(status => status.Description.Contains(query, StringComparison.OrdinalIgnoreCase))
                .OrderBy(status => status.RowId)
                .ToList();

            if (matches.Count == 0)
            {
                Console.WriteLine("  (none)");
                continue;
            }

            foreach (var match in matches)
            {
                Console.WriteLine($"  {match.RowId} - {match.Name} (Potency {match.ParamModifier})");
                Console.WriteLine($"    {match.Description}");
            }
        }
    }

    private static void DumpStatusByAction(string sqpackPath, List<uint> actionIds, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        var actionProps = typeof(StatusRow)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(prop => IsRowReference(prop.PropertyType, typeof(ActionRow)))
            .OrderBy(prop => prop.Name, StringComparer.Ordinal)
            .ToList();

        foreach (var actionId in actionIds)
        {
            Console.WriteLine($"Statuses linked to action {actionId}:");
            var matches = new List<(uint Id, string Name, int Potency, string Field)>();

            foreach (var status in statusSheet)
            {
                foreach (var prop in actionProps)
                {
                    var value = prop.GetValue(status);
                    if (value == null)
                    {
                        continue;
                    }

                    var rowId = ReadLazyRowId(value);
                    if (rowId != actionId)
                    {
                        continue;
                    }

                    matches.Add((status.RowId, GetStatusName(status), status.ParamModifier, prop.Name));
                }
            }

            if (matches.Count == 0)
            {
                Console.WriteLine("  (none)");
                continue;
            }

            foreach (var match in matches.OrderBy(m => m.Id))
            {
                Console.WriteLine($"  {match.Id} - {match.Name} (Potency {match.Potency}) via {match.Field}");
            }
        }
    }

    private static void DumpStatusByIcon(string sqpackPath, List<uint> iconIds, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        foreach (var iconId in iconIds)
        {
            Console.WriteLine($"Statuses with icon {iconId}:");
            var matches = statusSheet
                .Where(status => status.Icon == iconId)
                .Select(status => new { status.RowId, Name = status.Name.ExtractText(), status.ParamModifier })
                .OrderBy(status => status.RowId)
                .ToList();

            if (matches.Count == 0)
            {
                Console.WriteLine("  (none)");
                continue;
            }

            foreach (var match in matches)
            {
                Console.WriteLine($"  {match.RowId} - {match.Name} (Potency {match.ParamModifier})");
            }
        }
    }

    private static void DumpStatusInfo(string sqpackPath, List<uint> statusIds, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        foreach (var id in statusIds)
        {
            if (!statusSheet.TryGetRow(id, out var status))
            {
                Console.WriteLine($"Status {id} not found.");
                continue;
            }

            Console.WriteLine($"Status {id}: {status.Name.ExtractText()}");
            Console.WriteLine($"  Icon: {status.Icon}");
            Console.WriteLine($"  ParamModifier: {status.ParamModifier}");
            Console.WriteLine($"  StatusCategory: {status.StatusCategory}");
            Console.WriteLine($"  InflictedByActor: {status.InflictedByActor}");
            Console.WriteLine($"  CanDispel: {status.CanDispel}");
            Console.WriteLine($"  IsPermanent: {status.IsPermanent}");
            Console.WriteLine($"  TargetType: {status.TargetType}");
            Console.WriteLine($"  Description: {status.Description.ExtractText()}");
        }
    }

    private static void DumpStatusSchema()
    {
        Console.WriteLine("StatusRow properties:");
        foreach (var prop in typeof(StatusRow)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpActionSchema()
    {
        Console.WriteLine("ActionRow properties:");
        foreach (var prop in typeof(ActionRow)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpActionTransientSchema()
    {
        Console.WriteLine("ActionTransient properties:");
        foreach (var prop in typeof(Lumina.Excel.Sheets.ActionTransient)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpActionProcStatusSchema()
    {
        Console.WriteLine("ActionProcStatus properties:");
        foreach (var prop in typeof(Lumina.Excel.Sheets.ActionProcStatus)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpSheetTypes(string? filter)
    {
        var target = filter?.Trim();
        Console.WriteLine($"Sheet types{(string.IsNullOrWhiteSpace(target) ? string.Empty : $" matching \"{target}\"")}:");
        var sheets = typeof(ActionRow).Assembly.GetTypes()
            .Where(type => type.Namespace == "Lumina.Excel.Sheets")
            .Select(type => type.Name)
            .Where(name => string.IsNullOrWhiteSpace(target) || name.Contains(target, StringComparison.OrdinalIgnoreCase))
            .Distinct(StringComparer.Ordinal)
            .OrderBy(name => name, StringComparer.Ordinal)
            .ToList();

        foreach (var sheet in sheets)
        {
            Console.WriteLine($"  {sheet}");
        }
    }

    private static void DumpAozActionSchema()
    {
        Console.WriteLine("AozAction properties:");
        foreach (var prop in typeof(Lumina.Excel.Sheets.AozAction)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpAozActionTransientSchema()
    {
        Console.WriteLine("AozActionTransient properties:");
        foreach (var prop in typeof(Lumina.Excel.Sheets.AozActionTransient)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpSheetSchema(string sheetName)
    {
        var type = typeof(ActionRow).Assembly.GetTypes()
            .FirstOrDefault(t => t.Namespace == "Lumina.Excel.Sheets" && string.Equals(t.Name, sheetName, StringComparison.OrdinalIgnoreCase));
        if (type == null)
        {
            Console.WriteLine($"Sheet type not found: {sheetName}");
            return;
        }

        Console.WriteLine($"{type.Name} properties:");
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .OrderBy(prop => prop.Name, StringComparer.Ordinal))
        {
            Console.WriteLine($"  {prop.Name}: {prop.PropertyType.FullName}");
        }
    }

    private static void DumpActionInfo(string sqpackPath, List<uint> actionIds, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var actionSheet = gameData.GetExcelSheet<ActionRow>();
        var transientSheet = gameData.GetExcelSheet<Lumina.Excel.Sheets.ActionTransient>();
        if (actionSheet == null || transientSheet == null)
        {
            Console.Error.WriteLine("Action sheets not found.");
            return;
        }

        foreach (var id in actionIds)
        {
            if (!actionSheet.TryGetRow(id, out var action) || !transientSheet.TryGetRow(id, out var transient))
            {
                Console.WriteLine($"Action {id} not found.");
                continue;
            }

            Console.WriteLine($"Action {id}: {action.Name.ExtractText()}");
            Console.WriteLine($"Icon: {action.Icon}");
            Console.WriteLine(transient.Description.ExtractText());
            DumpActionStatuses(action);
            DumpActionProcStatus(action);
        }
    }

    private static void DumpActionStatuses(ActionRow action)
    {
        var statusProps = typeof(ActionRow)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(prop => prop.Name.Contains("Status", StringComparison.OrdinalIgnoreCase))
            .Where(prop =>
            {
                var type = prop.PropertyType;
                if (!type.IsGenericType)
                {
                    return false;
                }

                var args = type.GetGenericArguments();
                return args.Length == 1 && args[0] == typeof(StatusRow);
            })
            .OrderBy(prop => prop.Name, StringComparer.Ordinal)
            .ToList();

        foreach (var prop in statusProps)
        {
            var value = prop.GetValue(action);
            if (value == null)
            {
                continue;
            }

            var rowId = ReadLazyRowId(value);
            if (rowId == 0)
            {
                continue;
            }

            var status = ReadLazyRowValue(value);
            var statusName = GetStatusName(status);
            Console.WriteLine($"  {prop.Name}: {rowId} - {statusName}");
        }
    }

    private static void DumpActionProcStatus(ActionRow action)
    {
        var prop = typeof(ActionRow).GetProperty("ActionProcStatus", BindingFlags.Public | BindingFlags.Instance);
        if (prop == null)
        {
            return;
        }

        var value = prop.GetValue(action);
        if (value == null)
        {
            return;
        }

        var rowId = ReadLazyRowId(value);
        if (rowId == 0)
        {
            return;
        }

        Console.WriteLine($"  ActionProcStatus: {rowId}");

        var procStatus = ReadLazyRowValue(value);
        if (procStatus == null)
        {
            return;
        }

        var statusProps = procStatus.GetType()
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(propInfo => IsRowReference(propInfo.PropertyType, typeof(StatusRow)))
            .OrderBy(propInfo => propInfo.Name, StringComparer.Ordinal);

        foreach (var statusProp in statusProps)
        {
            var statusValue = statusProp.GetValue(procStatus);
            if (statusValue == null)
            {
                continue;
            }

            var statusId = ReadLazyRowId(statusValue);
            if (statusId == 0)
            {
                continue;
            }

            var status = ReadLazyRowValue(statusValue);
            var statusName = GetStatusName(status);
            Console.WriteLine($"    {statusProp.Name}: {statusId} - {statusName}");
        }
    }

    private static uint ReadLazyRowId(object value)
    {
        var rowIdProp = value.GetType().GetProperty("RowId", BindingFlags.Public | BindingFlags.Instance);
        if (rowIdProp == null)
        {
            return 0;
        }

        var rowIdValue = rowIdProp.GetValue(value);
        if (rowIdValue == null)
        {
            return 0;
        }

        return Convert.ToUInt32(rowIdValue, CultureInfo.InvariantCulture);
    }

    private static object? ReadLazyRowValue(object value)
    {
        var valueProp = value.GetType().GetProperty("Value", BindingFlags.Public | BindingFlags.Instance);
        return valueProp?.GetValue(value);
    }

    private static string GetStatusName(object? status)
    {
        if (status == null)
        {
            return string.Empty;
        }

        var nameProp = status.GetType().GetProperty("Name", BindingFlags.Public | BindingFlags.Instance);
        if (nameProp == null)
        {
            return string.Empty;
        }

        var nameValue = nameProp.GetValue(status);
        return nameValue?.ToString() ?? string.Empty;
    }

    private static void DumpStatusByJob(string sqpackPath, string jobAbbr, int? potencyFilter, Language language)
    {
        var gameData = new GameData(sqpackPath, new LuminaOptions
        {
            DefaultExcelLanguage = language,
        });

        var statusSheet = gameData.GetExcelSheet<StatusRow>();
        if (statusSheet == null)
        {
            Console.Error.WriteLine("Status sheet not found.");
            return;
        }

        var jobProp = typeof(ClassJobCategoryRow).GetProperty(jobAbbr, BindingFlags.Public | BindingFlags.Instance);
        if (jobProp == null || jobProp.PropertyType != typeof(bool))
        {
            Console.Error.WriteLine($"Unknown job abbreviation: {jobAbbr}");
            return;
        }

        Console.WriteLine($"Statuses for job {jobAbbr}{(potencyFilter.HasValue ? $" (Potency {potencyFilter})" : string.Empty)}:");
        foreach (var status in statusSheet)
        {
            var category = status.ClassJobCategory.Value;
            if (!(bool)jobProp.GetValue(category)!)
            {
                continue;
            }

            if (potencyFilter.HasValue && status.ParamModifier != potencyFilter.Value)
            {
                continue;
            }

            Console.WriteLine($"  {status.RowId} - {status.Name.ExtractText()} (Potency {status.ParamModifier})");
        }
    }

    private static void UpdatePotencyFile(
        string path,
        IDictionary<uint, float> skillPot,
        IDictionary<uint, uint> dotPot,
        IDictionary<uint, string> actionNames)
    {
        var originalBytes = File.ReadAllBytes(path);
        var content = Encoding.Latin1.GetString(originalBytes);
        var newline = content.Contains("\r\n", StringComparison.Ordinal) ? "\r\n" : "\n";

        var skillSection = BuildSkillPotSection(skillPot, actionNames, newline);
        var dotSection = BuildDotPotSection(dotPot, newline);

        content = ReplaceSection(content, SkillPotStart, SkillPotEnd, skillSection, newline);
        content = ReplaceSection(content, DotPotStart, DotPotEnd, dotSection, newline);

        var updatedBytes = Encoding.Latin1.GetBytes(content);
        File.WriteAllBytes(path, updatedBytes);
    }

    private static string BuildSkillPotSection(IDictionary<uint, float> skillPot, IDictionary<uint, string> actionNames, string newline)
    {
        var sb = new StringBuilder();
        sb.Append("        public static Dictionary<uint, float> SkillPot = new()").Append(newline);
        sb.Append("        {").Append(newline);
        foreach (var entry in skillPot.OrderBy(kvp => kvp.Key))
        {
            var potText = FormatFloat(entry.Value);
            sb.Append("            { ").Append(entry.Key).Append(", ").Append(potText).Append(" },");
            if (actionNames.TryGetValue(entry.Key, out var name) && !string.IsNullOrWhiteSpace(name))
            {
                sb.Append(" // ").Append(name);
            }
            sb.Append(newline);
        }
        sb.Append("        };");
        return sb.ToString();
    }

    private static string BuildDotPotSection(IDictionary<uint, uint> dotPot, string newline)
    {
        var sb = new StringBuilder();
        sb.Append("        public static Dictionary<uint, uint> DotPot = new()").Append(newline);
        sb.Append("        {").Append(newline);
        foreach (var entry in dotPot.OrderBy(kvp => kvp.Key))
        {
            sb.Append("            { ").Append(entry.Key).Append(", ").Append(entry.Value).Append(" },");
            sb.Append(newline);
        }
        sb.Append("        };");
        return sb.ToString();
    }

    private static string FormatFloat(float value)
    {
        var rounded = MathF.Round(value);
        if (MathF.Abs(value - rounded) < 0.0001f)
        {
            return ((int)rounded).ToString(CultureInfo.InvariantCulture) + "f";
        }

        return value.ToString("0.###", CultureInfo.InvariantCulture) + "f";
    }

    private static string ReplaceSection(string content, string startMarker, string endMarker, string newBody, string newline)
    {
        var startIndex = content.IndexOf(startMarker, StringComparison.Ordinal);
        var endIndex = content.IndexOf(endMarker, StringComparison.Ordinal);
        if (startIndex < 0 || endIndex < 0 || endIndex < startIndex)
        {
            throw new InvalidOperationException($"Markers not found: {startMarker} / {endMarker}");
        }

        var prefix = content.Substring(0, startIndex + startMarker.Length);
        var suffix = content.Substring(endIndex);
        return string.Concat(prefix, newline, newBody, newline, suffix);
    }

    private static bool IsRowReference(Type type, Type rowType)
    {
        if (!type.IsGenericType)
        {
            return false;
        }

        var args = type.GetGenericArguments();
        return args.Length == 1 && args[0] == rowType;
    }

    private sealed record ActionApiData(uint Id, string Name, string? Description);

    private sealed record Options(
        string? GamePath,
        string? PotencyPath,
        string? Ff14McpDotsPath,
        int MaxConcurrency,
        List<string> StatusQueries,
        List<string> StatusDescriptionQueries,
        List<uint> ActionDumpIds,
        List<string> ActionNameQueries,
        List<uint> StatusActionIds,
        List<uint> StatusIconQueries,
        List<uint> StatusDumpIds,
        string? StatusJobFilter,
        int? StatusPotencyFilter,
        Language QueryLanguage,
        bool DumpStatusSchema,
        bool DumpActionSchema,
        bool DumpActionTransientSchema,
        bool DumpActionProcStatusSchema,
        string? ListSheetsFilter,
        bool DumpAozActionSchema,
        bool DumpAozActionTransientSchema,
        string? SheetSchemaName,
        CancellationToken CancellationToken)
    {
        public static Options? Parse(string[] args)
        {
            string? gamePath = null;
            string? potencyPath = null;
            string? ff14McpDotsPath = null;
            var maxConcurrency = 8;
            var statusQueries = new List<string>();
            var statusDescriptionQueries = new List<string>();
            var actionDumpIds = new List<uint>();
            var actionNameQueries = new List<string>();
            var statusActionIds = new List<uint>();
            var statusIconQueries = new List<uint>();
            var statusDumpIds = new List<uint>();
            string? statusJobFilter = null;
            int? statusPotencyFilter = null;
            var queryLanguage = Language.ChineseSimplified;
            var dumpStatusSchema = false;
            var dumpActionSchema = false;
            var dumpActionTransientSchema = false;
            var dumpActionProcStatusSchema = false;
            string? listSheetsFilter = null;
            var dumpAozActionSchema = false;
            var dumpAozActionTransientSchema = false;
            string? sheetSchemaName = null;

            for (var i = 0; i < args.Length; i++)
            {
                var arg = args[i];
                if (arg.Equals("--game", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    gamePath = args[++i];
                }
                else if (arg.Equals("--potency", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    potencyPath = args[++i];
                }
                else if (arg.Equals("--max-concurrency", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (!int.TryParse(args[++i], out maxConcurrency) || maxConcurrency < 1)
                    {
                        maxConcurrency = 8;
                    }
                }
                else if (arg.Equals("--ff14mcp-dots", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    ff14McpDotsPath = args[++i];
                }
                else if (arg.Equals("--find-status", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    statusQueries.Add(args[++i]);
                }
                else if (arg.Equals("--find-status-desc", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    statusDescriptionQueries.Add(args[++i]);
                }
                else if (arg.Equals("--dump-action", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (uint.TryParse(args[++i], out var actionId))
                    {
                        actionDumpIds.Add(actionId);
                    }
                }
                else if (arg.Equals("--find-action", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    actionNameQueries.Add(args[++i]);
                }
                else if (arg.Equals("--status-action", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (uint.TryParse(args[++i], out var actionId))
                    {
                        statusActionIds.Add(actionId);
                    }
                }
                else if (arg.Equals("--find-status-icon", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (uint.TryParse(args[++i], out var iconId))
                    {
                        statusIconQueries.Add(iconId);
                    }
                }
                else if (arg.Equals("--dump-status", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (uint.TryParse(args[++i], out var statusId))
                    {
                        statusDumpIds.Add(statusId);
                    }
                }
                else if (arg.Equals("--status-job", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    statusJobFilter = args[++i];
                }
                else if (arg.Equals("--status-potency", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    if (int.TryParse(args[++i], out var value))
                    {
                        statusPotencyFilter = value;
                    }
                }
                else if (arg.Equals("--lang", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    queryLanguage = ParseLanguage(args[++i]);
                }
                else if (arg.Equals("--status-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpStatusSchema = true;
                }
                else if (arg.Equals("--action-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpActionSchema = true;
                }
                else if (arg.Equals("--action-transient-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpActionTransientSchema = true;
                }
                else if (arg.Equals("--action-proc-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpActionProcStatusSchema = true;
                }
                else if (arg.Equals("--list-sheets", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 1 < args.Length && !args[i + 1].StartsWith("--", StringComparison.Ordinal))
                    {
                        listSheetsFilter = args[++i];
                    }
                    else
                    {
                        listSheetsFilter = string.Empty;
                    }
                }
                else if (arg.Equals("--aoz-action-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpAozActionSchema = true;
                }
                else if (arg.Equals("--aoz-action-transient-schema", StringComparison.OrdinalIgnoreCase))
                {
                    dumpAozActionTransientSchema = true;
                }
                else if (arg.Equals("--sheet-schema", StringComparison.OrdinalIgnoreCase) && i + 1 < args.Length)
                {
                    sheetSchemaName = args[++i];
                }
                else if (arg.Equals("--help", StringComparison.OrdinalIgnoreCase) || arg.Equals("-h", StringComparison.OrdinalIgnoreCase))
                {
                    return null;
                }
            }

            return new Options(
                gamePath,
                potencyPath,
                ff14McpDotsPath,
                maxConcurrency,
                statusQueries,
                statusDescriptionQueries,
                actionDumpIds,
                actionNameQueries,
                statusActionIds,
                statusIconQueries,
                statusDumpIds,
                statusJobFilter,
                statusPotencyFilter,
                queryLanguage,
                dumpStatusSchema,
                dumpActionSchema,
                dumpActionTransientSchema,
                dumpActionProcStatusSchema,
                listSheetsFilter,
                dumpAozActionSchema,
                dumpAozActionTransientSchema,
                sheetSchemaName,
                CancellationToken.None);
        }
    }

    private sealed record Ff14McpDotEntry(
        [property: JsonPropertyName("level")] int Level,
        [property: JsonPropertyName("dot")] Ff14McpDotInfo Dot,
        [property: JsonPropertyName("status")] Ff14McpStatusInfo Status)
    {
        public uint StatusId => Status.Id;
        public uint DotPotency => Dot.Potency;
    }

    private sealed record Ff14McpDotInfo([property: JsonPropertyName("potency")] uint Potency);
    private sealed record Ff14McpStatusInfo([property: JsonPropertyName("id")] uint Id);

    private static Language ParseLanguage(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return Language.ChineseSimplified;
        }

        var normalized = value.Trim().ToLowerInvariant();
        return normalized switch
        {
            "en" or "eng" => Language.English,
            "ja" or "jp" => Language.Japanese,
            "fr" => Language.French,
            "de" => Language.German,
            "tw" or "zh-tw" => Language.ChineseTraditional,
            "cn" or "zh" or "zh-cn" => Language.ChineseSimplified,
            _ => Language.ChineseSimplified,
        };
    }
}
